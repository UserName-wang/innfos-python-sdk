Metadata-Version: 2.1
Name: innfos-python-sdk
Version: 1.0.0
Summary: Pure Python SDK for INNFOS Gluon robotic arm
Home-page: https://github.com/innfos/gluon-python-sdk
Author: INNFOS Python SDK Team
License: UNKNOWN
Platform: UNKNOWN
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: Intended Audience :: Education
Classifier: Intended Audience :: Science/Research
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.7
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Topic :: Software Development :: Libraries
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: Topic :: Scientific/Engineering
Classifier: Topic :: System :: Hardware :: Hardware Drivers
Requires-Python: >=3.7
Description-Content-Type: text/markdown
Provides-Extra: dev

# INNFOS Python SDK

Pure Python implementation of the SDK for INNFOS Gluon robotic arm, based on the MINTASCA communication protocol.

## Overview

This is a pure Python SDK for controlling INNFOS smart actuators used in the Gluon robotic arm. Unlike the C++ SDK with Python bindings, this implementation is written entirely in Python, making it:

- Cross-platform compatible (x86, ARM, etc.)
- Easy to install and use
- No compilation required
- Perfect for integration with ROS 2 and other Python-based robotics frameworks

## Features

- Full implementation of the MINTASCA UDP communication protocol
- Control individual actuators or the entire robotic arm
- Position, speed, and current control modes
- Real-time monitoring of actuator status (position, speed, current, voltage, temperature)
- Automatic CRC16 checksum calculation and verification
- Error handling and exception management
- Compatible with Jetson and other ARM-based platforms

## Installation

```bash
# Clone the repository
git clone https://github.com/innfos/gluon-python-sdk.git

# Navigate to the directory
cd innfos-python-sdk

# Install the package
pip install .
```

Or install in development mode:
```bash
pip install -e .
```

## Usage

### Basic Setup

```python
from innfos_python_sdk import ActuatorController

# Initialize the controller
controller = ActuatorController.init_controller()

# Connect to the ECB (Ethernet to CAN Bridge)
if controller.connect():
    print("Connected to ECB")
else:
    print("Failed to connect to ECB")
    exit(1)

# Find connected actuators
error_code = None
actuators = controller.lookup_actuators(error_code)

if actuators:
    print(f"Found {len(actuators)} actuators")
    for actuator_id, serial in actuators:
        print(f"  Actuator ID: {actuator_id}, Serial: {serial}")
else:
    print("No actuators found")
```

### Controlling Individual Actuators

```python
# Get the first actuator
actuator_ids = controller.get_actuator_id_array()
if actuator_ids:
    actuator_id = actuator_ids[0]
    actuator = controller.get_actuator(actuator_id)
    
    # Enable the actuator
    if actuator.enable():
        print(f"Actuator {actuator_id} enabled")
    
    # Set position (in rotations)
    actuator.set_position(10.0)  # Rotate 10 full turns
    
    # Get current position
    position = actuator.get_position()
    print(f"Current position: {position} rotations")
    
    # Disable the actuator
    actuator.disable()
```

### Controlling Multiple Actuators

```python
# Enable all actuators
controller.enable_all_actuators()

# Set positions for all actuators
positions = [0.0, 0.5, 1.0, 1.5, 2.0, 2.5]  # Example positions
controller.set_all_positions(positions)

# Get positions for all actuators
current_positions = controller.get_all_positions()
print(f"Current positions: {current_positions}")

# Disable all actuators
controller.disable_all_actuators()
```

## API Reference

### ActuatorController

Main controller class for managing the robotic arm.

- `init_controller(ip, port)` - Initialize the controller
- `get_instance()` - Get the singleton instance
- `connect()` - Connect to the ECB
- `disconnect()` - Disconnect from the ECB
- `lookup_actuators()` - Find connected actuators
- `has_available_actuator()` - Check if any actuators are connected
- `get_actuator_id_array()` - Get list of actuator IDs
- `get_actuator_unified_id_array()` - Get list of actuator IDs with IP addresses
- `get_unified_id_group(ip)` - Get actuators connected to specific IP
- `get_actuator(id)` - Get actuator by ID
- `process_events()` - Process controller events
- `enable_all_actuators()` - Enable all actuators
- `disable_all_actuators()` - Disable all actuators
- `set_all_positions(positions)` - Set positions for all actuators
- `get_all_positions()` - Get positions for all actuators

### Actuator

Class representing an individual actuator.

- `enable()` - Enable the actuator
- `disable()` - Disable the actuator
- `set_mode(mode)` - Set control mode
- `set_position(position)` - Set target position
- `set_speed(speed)` - Set target speed
- `set_current(current)` - Set target current
- `get_position()` - Get current position
- `get_speed()` - Get current speed
- `get_current()` - Get current current
- `get_voltage()` - Get current voltage
- `get_temperature()` - Get motor temperature
- `store_parameters()` - Store parameters to EEPROM

## Requirements

- Python 3.7 or higher
- Network access to the ECB (Ethernet to CAN Bridge)
- INNFOS Gluon robotic arm or compatible actuators

## Platform Support

This pure Python implementation works on:

- x86/x64 platforms (Linux, Windows, macOS)
- ARM platforms (Jetson, Raspberry Pi, etc.)
- Any platform that supports Python 3.7+

## License

This project is licensed under the MIT License - see the LICENSE file for details.

## Contributing

Contributions are welcome! Please feel free to submit a Pull Request.

